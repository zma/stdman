.TH std::ranges::safe_iterator_t,std::ranges::safe_subrange_t 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::safe_iterator_t,std::ranges::safe_subrange_t \- std::ranges::safe_iterator_t,std::ranges::safe_subrange_t

.SH Synopsis
   Defined in header <ranges>
   template<Range R>

   using safe_iterator_t = std::conditional_t<__ForwardingRange<R>, \fB(1)\fP \fI(since C++20)\fP

   ranges::iterator_t<R>, ranges::dangling>;
   template<Range R>

   using safe_subrange_t = std::conditional_t<__ForwardingRange<R>, \fB(2)\fP \fI(since C++20)\fP

   ranges::subrange<ranges::iterator_t<R>>, ranges::dangling>;

   1) Same as ranges::iterator_t when R models exposition-only concept __ForwardingRange, otherwise yields ranges::dangling instead.
   2) Similar to \fB(1)\fP, but it yields a specialization of ranges::subrange when the the same condition is met.

   These two alias templates are used by some constrained algorithms to avoid returning potentially dangling iterators or views.

.SH See also

   dangling a placeholder type indicating that an iterator or a subrange should not be returned since it would be dangling
            \fI(class)\fP
