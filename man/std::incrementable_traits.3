.TH std::incrementable_traits 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::incrementable_traits \- std::incrementable_traits

.SH Synopsis

Defined in header <iterator>
template< class I >                                                 \fB(1)\fP \fI(since C++20)\fP
struct incrementable_traits { };
template< class T >
requires std::is_object_v<T>                                        \fB(2)\fP \fI(since C++20)\fP
struct incrementable_traits<T*>;
template< class T >                                                 \fB(3)\fP \fI(since C++20)\fP
struct incrementable_traits<const T> : incrementable_traits<T> { };
template< class T >
requires requires { typename T::difference_type; }                  \fB(4)\fP \fI(since C++20)\fP
struct incrementable_traits<T>;
template< class T >
requires (!requires { typename T::difference_type; }) &&            \fB(5)\fP \fI(since C++20)\fP
requires(const T& a, const T& b) { { a - b } -> Integral; }
struct incrementable_traits<T>;

Computes the associated difference type of the type I, if any. Users may specialize incrementable_traits for a program-defined type.
1) Primary template is an empty struct.
2) Specialization for pointers. Provides a member type difference_type equal to std::ptrdiff_t.
3) Specialization for const-qualified types.
4) Specialization for types that define a public and accessible member type difference_type. Provides a member type difference_type equal to T::difference_type.
5) Specialization for types that do not define a public and accessible member type difference_type but do support subtraction. Provides a member type difference_type equal to std::make_signed_t<decltype(std::declval<T>() - std::declval<T>())>. The implicit expression variations rule (see below) applies to the expression a - b.

Implicit expression variations

A requires-expression that uses an expression that is non-modifying for some constant lvalue operand also implicitly requires additional variations of that expression that accept a non-constant lvalue or (possibly constant) rvalue for the given operand unless such an expression variation is explicitly required with differing semantics. These implicit expression variations must meet the same semantic requirements of the declared expression. The extent to which an implementation validates the syntax of the variations is unspecified.

.SH Example


 This section is incomplete
 Reason: no example


.SH See also


                        specifies that a Semiregular type can be incremented with pre- and post-increment operators
WeaklyIncrementable     (concept)

iter_value_t
iter_reference_t        computes the associate types of an iterator
iter_difference_t       (alias template)
iter_rvalue_reference_t
iter_common_reference_t
                        provides uniform interface to the properties of an iterator
iterator_traits         \fI(class template)\fP




