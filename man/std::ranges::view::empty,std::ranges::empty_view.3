.TH std::ranges::view::empty,std::ranges::empty_view 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::view::empty,std::ranges::empty_view \- std::ranges::view::empty,std::ranges::empty_view

.SH Synopsis

template<class T>
requires is_object_v<T>                                   \fB(1)\fP \fI(since C++20)\fP
class empty_view : public view_interface<empty_view<T>>
namespace view {
template<class T> inline constexpr empty_view<T> empty{}; \fB(2)\fP \fI(since C++20)\fP
}

1) A range adaptor that produces a View of no elements of a particular type.
2) Variable template for empty_view.

.SH Member functions


 std::ranges::empty_view::begin


static constexpr T* begin() noexcept { return nullptr; }

empty_view does not reference any element.

 std::ranges::empty_view::end


static constexpr T* end() noexcept { return nullptr; }

empty_view does not reference any element.

 std::ranges::empty_view::data


static constexpr T* data() noexcept { return nullptr; }

empty_view does not reference any element.

 std::ranges::empty_view::size


static constexpr std::ptrdiff_t size() noexcept { return 0; }

empty_view is always empty.

 std::ranges::empty_view::empty


static constexpr bool empty() noexcept { return true; }

empty_view is always empty.

.SH Non-member functions


 begin, end(std::ranges::empty_view)


friend constexpr T* begin(empty_view) noexcept { return nullptr; } \fB(1)\fP
friend constexpr T* end(empty_view) noexcept { return nullptr; }   \fB(2)\fP

These functions are not visible to ordinary unqualified or qualified_lookup, and can only be found by argument-dependent_lookup when std::ranges::empty_view<T> is an associated class of the arguments.

.SH Example


// Run this code

  #include <ranges>

  int main()
  {
      std::ranges::empty_view<int> e;
      static_assert(std::ranges::empty(e));
      static_assert(0 == e.size());
  }





