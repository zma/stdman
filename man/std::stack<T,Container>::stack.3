.TH std::stack<T,Container>::stack 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::stack<T,Container>::stack \- std::stack<T,Container>::stack

.SH Synopsis

  stack() : stack(Container()) { }                       \fB(1)\fP \fI(since C++11)\fP
  explicit stack( const Container& cont = Container() );                   \fI(until C++11)\fP
  explicit stack( const Container& cont );                                 \fI(since C++11)\fP
  explicit stack( Container&& cont );                        \fB(3)\fP           \fI(since C++11)\fP
  stack( const stack& other );                               \fB(4)\fP
  stack( stack&& other );                                    \fB(5)\fP           \fI(since C++11)\fP
  template< class Alloc >                                    \fB(6)\fP           \fI(since C++11)\fP
  explicit stack( const Alloc& alloc );
  template< class Alloc >                                \fB(2)\fP \fB(7)\fP           \fI(since C++11)\fP
  stack( const Container& cont, const Alloc& alloc );
  template< class Alloc >                                    \fB(8)\fP           \fI(since C++11)\fP
  stack( Container&& cont, const Alloc& alloc );
  template< class Alloc >                                    \fB(9)\fP           \fI(since C++11)\fP
  stack( const stack& other, const Alloc& alloc );
  template< class Alloc >                                    \fB(10)\fP          \fI(since C++11)\fP
  stack( stack&& other, const Alloc& alloc );

  Constructs new underlying container of the container adaptor from a variety of data sources.
  1) Default constructor. Value-initializes the container.
  2) Copy-constructs the underlying container c with the contents of cont.
  This is also the default constructor.
  \fI(until C++11)\fP
  3) Move-constructs the underlying container c with std::move(cont).
  4) Copy constructor. The adaptor is copy-constructed with the contents of other.c. (implicitly declared)
  5) Move constructor. The adaptor is constructed with std::move(other.c). (implicitly declared)
  6-10) The following constructors are only defined if std::uses_allocator<container_type, Alloc>::value == true, that is, if the underlying container is an allocator-aware container (true for all standard library containers that can be used with stack).
  6) Constructs the underlying container using alloc as allocator, as if by c(alloc).
  7) Constructs the underlying container with the contents of cont and using alloc as allocator, as if by c(cont, alloc).
  8) Constructs the underlying container with the contents of cont using move semantics while utilizing alloc as allocator, as if by c(std::move(cont), alloc).
  9) Constructs the adaptor with the contents of other.c and using alloc as allocator, as if by c(other.c, alloc).
  10) Constructs the adaptor with the contents of other using move semantics while utilizing alloc as allocator, as if by c(std::move(other.c), alloc).

.SH Parameters


  alloc       - allocator to use for all memory allocations of the underlying container
  other       - another container adaptor to be used as source to initialize the underlying container
  cont        - container to be used as source to initialize the underlying container
  first, last - range of elements to initialize with
.SH Type requirements
  -
  Alloc must meet the requirements of Allocator.
  -
  Container must meet the requirements of Container. The constructors (5-10) are only defined if Container meets the requirements of AllocatorAwareContainer
  -
  InputIt must meet the requirements of LegacyInputIterator.


.SH Complexity

  Same as the corresponding operation on the wrapped container.

  Defect reports

  The following behavior-changing defect reports were applied retroactively to previously published C++ standards.

  DR      Applied to Behavior as published            Correct behavior
  P0935R0 C++11      default constructor was explicit made implicit


.SH Example

  
// Run this code

    #include <stack>
    #include <deque>
    #include <iostream>

    int main()
    {
        std::stack<int> c1;
        c1.push(5);
        std::cout << c1.size() << '\\n';

        std::stack<int> c2(c1);
        std::cout << c2.size() << '\\n';

        std::deque<int> deq {3, 1, 4, 1, 5};
        std::stack<int> c3(deq);
        std::cout << c3.size() << '\\n';
    }

.SH Output:

    1
    1
    5


.SH See also


            assigns values to the container adaptor
  operator= \fI(public member function)\fP




