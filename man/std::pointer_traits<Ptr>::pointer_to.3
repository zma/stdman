.TH std::pointer_traits<Ptr>::pointer_to 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::pointer_traits<Ptr>::pointer_to \- std::pointer_traits<Ptr>::pointer_to

.SH Synopsis

Defined in header <memory>
static pointer                          \fB(1)\fP \fI(since C++11)\fP
pointer_to( element_type& r );              (member of pointer_traits<Ptr> specialization)
static pointer                                                                             \fI(since C++11)\fP
pointer_to( element_type& r ) noexcept;                                                    \fI(until C++20)\fP
                                        \fB(2)\fP                                                (member of pointer_traits<T*> specialization)
static constexpr pointer                                                                   \fI(since C++20)\fP
pointer_to( element_type& r ) noexcept;                                                    (member of pointer_traits<T*> specialization)

Constructs a dereferenceable pointer or pointer-like object ("fancy pointer") to its argument.
1) The version of this function in the non-specialized std::pointer_traits template simply calls Ptr::pointer_to(r), and if Ptr does not provide a static member function pointer_to, instantiation of this function is a compile-time error.
2) The version of this function in the specialization of std::pointer_traits for pointer types returns std::addressof(r)

.SH Parameters


r - reference to an object of type element_type&, except if element_type is void, in which case the type of r is unspecified


.SH Return value

A dereferenceable pointer to r, of the type pointer_traits<>::pointer.

.SH Exceptions

1) Unspecified (typically same as Ptr::pointer_to)


.SH Notes

The Boost.Intrusive_library_version of this function returns pointer(std::addressof(r)) if Ptr::pointer_to does not exist.

.SH See also



addressof             obtains actual address of an object, even if the & operator is overloaded
                      \fI(function template)\fP
\fI(C++11)\fP

address               obtains the address of an object, even if operator& is overloaded
                      \fI(public member function of std::allocator<T>)\fP
(deprecated in C++17)
(removed in C++20)

to_address            obtains a raw pointer from a fancy pointer (inverse of pointer_to)
                      \fI(public static member function)\fP
\fB[static]\fP (C++20)

to_address            obtains a raw pointer from a pointer-like type
                      \fI(function template)\fP
(C++20)




