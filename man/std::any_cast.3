.TH std::any_cast 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::any_cast \- std::any_cast

.SH Synopsis

  template<class T>                               \fB(1)\fP \fI(since C++17)\fP
  T any_cast(const any& operand);
  template<class T>                               \fB(2)\fP \fI(since C++17)\fP
  T any_cast(any& operand);
  template<class T>                               \fB(3)\fP \fI(since C++17)\fP
  T any_cast(any&& operand);
  template<class T>                               \fB(4)\fP \fI(since C++17)\fP
  const T* any_cast(const any* operand) noexcept;
  template<class T>                               \fB(5)\fP \fI(since C++17)\fP
  T* any_cast(any* operand) noexcept;

  Performs type-safe access to the contained object.
  Let U be std::remove_cv_t<std::remove_reference_t<T>>.
  1) The program is ill-formed if std::is_constructible_v<T, const U&> is false.
  2) The program is ill-formed if std::is_constructible_v<T, U&> is false.
  3) The program is ill-formed if std::is_constructible_v<T, U> is false.

.SH Parameters


  operand - target any object


.SH Return value

  1-2) Returns static_cast<T>(*std::any_cast<U>(&operand))
  3) Returns static_cast<T>(std::move(*std::any_cast<U>(&operand))).
  4-5) If operand is not a null pointer, and the typeid of the requested T matches that of the contents of operand, a pointer to the value contained by operand, otherwise a null pointer.

.SH Exceptions

  1-3) Throws std::bad_any_cast if the typeid of the requested T does not match that of the contents of operand.

.SH Example

  
// Run this code

    #include <string>
    #include <iostream>
    #include <any>
    #include <utility>

    int main()
    {
        // simple example

        auto a = std::any(12);

        std::cout << std::any_cast<int>(a) << '\\n';

        try {
            std::cout << std::any_cast<std::string>(a) << '\\n';
        }
        catch(const std::bad_any_cast& e) {
            std::cout << e.what() << '\\n';
        }

        // pointer example

        if (int* i = std::any_cast<int>(&a)) {
           std::cout << "a is int: " << *i << '\\n';
        } else if (std::string* s = std::any_cast<std::string>(&a)) {
           std::cout << "a is std::string: " << *s << '\\n';
        } else {
           std::cout << "a is another type or unset\\n";
        }

        // advanced example

        a = std::string("hello");

        auto& ra = std::any_cast<std::string&>(a); //< reference
        ra[1] = 'o';

        std::cout << "a: "
            << std::any_cast<const std::string&>(a) << '\\n'; //< const reference

        auto b = std::any_cast<std::string&&>(std::move(a)); //< rvalue reference

        // Note: 'b' is a move-constructed std::string,
        // 'a' is left in valid but unspecified state

        std::cout << "a: " << *std::any_cast<std::string>(&a) //< pointer
            << "b: " << b << '\\n';
    }

.SH Possible output:

    12
    bad any_cast
    a is int: 12
    a: hollo
    a: b: hollo




