.TH std::numeric_limits 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::numeric_limits \- std::numeric_limits

.SH Synopsis

  Defined in header <limits>
  template< class T > class numeric_limits;

  The numeric_limits class template provides a standardized way to query various properties of arithmetic types (e.g. the largest possible value for type int is std::numeric_limits<int>::max()).
  This information is provided via specializations of the numeric_limits template. The standard library makes available specializations for all arithmetic types:

  Defined in header <limits>
  template<> class numeric_limits<bool>;
  template<> class numeric_limits<char>;
  template<> class numeric_limits<signed char>;
  template<> class numeric_limits<unsigned char>;
  template<> class numeric_limits<wchar_t>;
  template<> class numeric_limits<char8_t>; // C++20 feature
  template<> class numeric_limits<char16_t>; // C++11 feature
  template<> class numeric_limits<char32_t>; // C++11 feature
  template<> class numeric_limits<short>;
  template<> class numeric_limits<unsigned short>;
  template<> class numeric_limits<int>;
  template<> class numeric_limits<unsigned int>;
  template<> class numeric_limits<long>;
  template<> class numeric_limits<unsigned long>;
  template<> class numeric_limits<long long>;
  template<> class numeric_limits<unsigned long long>;
  template<> class numeric_limits<float>;
  template<> class numeric_limits<double>;
  template<> class numeric_limits<long double>;

  Additionally, a specialization exists for every cv-qualified version of each arithmetic type, identical to the unqualified specialization, e.g. std::numeric_limits<const int>, std::numeric_limits<volatile int>, and std::numeric_limits<const volatile int> are provided and are equivalent to std::numeric_limits<int>.
  The standard library types that are aliases of arithmetic types (such as std::size_t or std::streamsize) may also be examined with the std::numeric_limits type traits.
  Non-arithmetic standard types, such as std::complex<T> or std::nullptr_t, do not have specializations.
  Implementations may provide specializations of std::numeric_limits for implementation-specific types: e.g. GCC provides std::numeric_limits<__int128>. Non-standard libraries may add_specializations for library-provided types, e.g. OpenEXR provides std::numeric_limits<half> for a 16-bit floating-point type.

.SH Template parameters


  T - a type to retrieve numeric properties for


.SH Member constants



  is_specialized    identifies types for which std::numeric_limits is specialized
                    \fI(public static member constant)\fP
  \fB[static]\fP

  is_signed         identifies signed types
                    \fI(public static member constant)\fP
  \fB[static]\fP

  is_integer        identifies integer types
                    \fI(public static member constant)\fP
  \fB[static]\fP

  is_exact          identifies exact types
                    \fI(public static member constant)\fP
  \fB[static]\fP

  has_infinity      identifies floating-point types that can represent the special value "positive infinity"
                    \fI(public static member constant)\fP
  \fB[static]\fP

  has_quiet_NaN     identifies floating-point types that can represent the special value "quiet not-a-number" (NaN)
                    \fI(public static member constant)\fP
  \fB[static]\fP

  has_signaling_NaN identifies floating-point types that can represent the special value "signaling not-a-number" (NaN)
                    \fI(public static member constant)\fP
  \fB[static]\fP

  has_denorm        identifies the denormalization style used by the floating-point type
                    \fI(public static member constant)\fP
  \fB[static]\fP

  has_denorm_loss   identifies the floating-point types that detect loss of precision as denormalization loss rather than inexact result
                    \fI(public static member constant)\fP
  \fB[static]\fP

  round_style       identifies the rounding style used by the type
                    \fI(public static member constant)\fP
  \fB[static]\fP

  is_iec559         identifies the IEC 559/IEEE 754 floating-point types
                    \fI(public static member constant)\fP
  \fB[static]\fP

  is_bounded        identifies types that represent a finite set of values
                    \fI(public static member constant)\fP
  \fB[static]\fP

  is_modulo         identifies types that handle overflows with modulo arithmetic
                    \fI(public static member constant)\fP
  \fB[static]\fP

  digits            number of radix digits that can be represented without change
                    \fI(public static member constant)\fP
  \fB[static]\fP

  digits10          number of decimal digits that can be represented without change
                    \fI(public static member constant)\fP
  \fB[static]\fP

  max_digits10      number of decimal digits necessary to differentiate all values of this type
                    \fI(public static member constant)\fP
  \fB[static]\fP \fI(C++11)\fP

  radix             the radix or integer base used by the representation of the given type
                    \fI(public static member constant)\fP
  \fB[static]\fP

  min_exponent      one more than the smallest negative power of the radix that is a valid normalized floating-point value
                    \fI(public static member constant)\fP
  \fB[static]\fP

  min_exponent10    the smallest negative power of ten that is a valid normalized floating-point value
                    \fI(public static member constant)\fP
  \fB[static]\fP

  max_exponent      one more than the largest integer power of the radix that is a valid finite floating-point value
                    \fI(public static member constant)\fP
  \fB[static]\fP

  max_exponent10    the largest integer power of 10 that is a valid finite floating-point value
                    \fI(public static member constant)\fP
  \fB[static]\fP

  traps             identifies types which can cause arithmetic operations to trap
                    \fI(public static member constant)\fP
  \fB[static]\fP

  tinyness_before   identifies floating-point types that detect tinyness before rounding
                    \fI(public static member constant)\fP
  \fB[static]\fP


.SH Member functions



  min              returns the smallest finite value of the given type
                   \fI(public static member function)\fP
  \fB[static]\fP

  lowest           returns the lowest finite value of the given type
                   \fI(public static member function)\fP
  \fB[static]\fP \fI(C++11)\fP

  max              returns the largest finite value of the given type
                   \fI(public static member function)\fP
  \fB[static]\fP

  epsilon          returns the difference between 1.0 and the next representable value of the given floating-point type
                   \fI(public static member function)\fP
  \fB[static]\fP

  round_error      returns the maximum rounding error of the given floating-point type
                   \fI(public static member function)\fP
  \fB[static]\fP

  infinity         returns the positive infinity value of the given floating-point type
                   \fI(public static member function)\fP
  \fB[static]\fP

  quiet_NaN        returns a quiet NaN value of the given floating-point type
                   \fI(public static member function)\fP
  \fB[static]\fP

  signaling_NaN    returns a signaling NaN value of the given floating-point type
                   \fI(public static member function)\fP
  \fB[static]\fP

  denorm_min       returns the smallest positive subnormal value of the given floating-point type
                   \fI(public static member function)\fP
  \fB[static]\fP


.SH Helper classes


                     indicates floating-point rounding modes
  float_round_style  \fI(enum)\fP
                     indicates floating-point denormalization modes
  float_denorm_style \fI(enum)\fP


.SH Relationship with C library macro constants


                                     Members
  Specialization                     min()     lowest()  max()            epsilon()    digits        digits10 min_exponent min_exponent10  max_exponent max_exponent10  radix
                                               \fI(C++11)\fP
  numeric_limits<bool>                                                                                                                                                  2
  numeric_limits<char>               CHAR_MIN  CHAR_MIN  CHAR_MAX                                                                                                       2
  numeric_limits<signed char>        SCHAR_MIN SCHAR_MIN SCHAR_MAX                                                                                                      2
  numeric_limits<unsigned char>      0   0   UCHAR_MAX                                                                                                      2
  numeric_limits<wchar_t>            WCHAR_MIN WCHAR_MIN WCHAR_MAX                                                                                                      2
  numeric_limits<char8_t>            0   0   UCHAR_MAX                                                                                                      2
  numeric_limits<char16_t>           0   0   UINT_LEAST16_MAX                                                                                               2
  numeric_limits<char32_t>           0   0   UINT_LEAST32_MAX                                                                                               2
  numeric_limits<short>              SHRT_MIN  SHRT_MIN  SHRT_MAX                                                                                                       2
  numeric_limits<signed short>
  numeric_limits<unsigned short>     0   0   USHRT_MAX                                                                                                      2
  numeric_limits<int>                INT_MIN   INT_MIN   INT_MAX                                                                                                        2
  numeric_limits<signed int>
  numeric_limits<unsigned int>       0   0   UINT_MAX                                                                                                       2
  numeric_limits<long>               LONG_MIN  LONG_MIN  LONG_MAX                                                                                                       2
  numeric_limits<signed long>
  numeric_limits<unsigned long>      0   0   ULONG_MAX                                                                                                      2
  numeric_limits<long long>          LLONG_MIN LLONG_MIN LLONG_MAX                                                                                                      2
  numeric_limits<signed long long>
  numeric_limits<unsigned long long> 0   0   ULLONG_MAX                                                                                                     2
  numeric_limits<float>              FLT_MIN   -FLT_MAX  FLT_MAX          FLT_EPSILON  FLT_MANT_DIG  FLT_DIG  FLT_MIN_EXP  FLT_MIN_10_EXP  FLT_MAX_EXP  FLT_MAX_10_EXP  FLT_RADIX
  numeric_limits<double>             DBL_MIN   -DBL_MAX  DBL_MAX          DBL_EPSILON  DBL_MANT_DIG  DBL_DIG  DBL_MIN_EXP  DBL_MIN_10_EXP  DBL_MAX_EXP  DBL_MAX_10_EXP  FLT_RADIX
  numeric_limits<long double>        LDBL_MIN  -LDBL_MAX LDBL_MAX         LDBL_EPSILON LDBL_MANT_DIG LDBL_DIG LDBL_MIN_EXP LDBL_MIN_10_EXP LDBL_MAX_EXP LDBL_MAX_10_EXP FLT_RADIX


.SH Example

  
// Run this code

    #include <limits>
    #include <iostream>

    int main()
    {
        std::cout << "type\\tlowest()\\tmin()\\t\\tmax()\\n\\n";

        std::cout << "uchar\\t"
                  << +std::numeric_limits<unsigned char>::lowest() << '\\t' << '\\t'
                  << +std::numeric_limits<unsigned char>::min() << '\\t' << '\\t'
                  << +std::numeric_limits<unsigned char>::max() << '\\n';
        std::cout << "int\\t"
                  << std::numeric_limits<int>::lowest() << '\\t'
                  << std::numeric_limits<int>::min() << '\\t'
                  << std::numeric_limits<int>::max() << '\\n';
        std::cout << "float\\t"
                  << std::numeric_limits<float>::lowest() << '\\t'
                  << std::numeric_limits<float>::min() << '\\t'
                  << std::numeric_limits<float>::max() << '\\n';
        std::cout << "double\\t"
                  << std::numeric_limits<double>::lowest() << '\\t'
                  << std::numeric_limits<double>::min() << '\\t'
                  << std::numeric_limits<double>::max() << '\\n';
    }

.SH Possible output:

    type	lowest()	min()		max()

    uchar	0		0		255
    int	-2147483648	-2147483648	2147483647
    float	-3.40282e+38	1.17549e-38	3.40282e+38
    double	-1.79769e+308	2.22507e-308	1.79769e+308


.SH See also


  * Fixed_width_integer_types
  * Arithmetic_types
  * C++_type_system_overview
  * Type_support_(basic_types,_RTTI,_type_traits)




