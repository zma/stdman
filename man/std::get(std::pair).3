.TH std::get(std::pair) 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::get(std::pair) \- std::get(std::pair)

.SH Synopsis

Defined in header <utility>
template< size_t I, class T1, class T2 >                               \fI(since C++11)\fP
typename std::tuple_element<I, std::pair<T1,T2> >::type&           \fB(1)\fP \fI(until C++14)\fP
get( pair<T1, T2>& p ) noexcept;
template< size_t I, class T1, class T2 >
constexpr std::tuple_element_t<I, std::pair<T1,T2> >&              \fB(1)\fP \fI(since C++14)\fP
get( pair<T1, T2>& p ) noexcept;
template< size_t I, class T1, class T2 >                                              \fI(since C++11)\fP
const typename std::tuple_element<I, std::pair<T1,T2> >::type&         \fB(2)\fP            \fI(until C++14)\fP
get( const pair<T1,T2>& p ) noexcept;
template< size_t I, class T1, class T2 >
constexpr const std::tuple_element_t<I, std::pair<T1,T2> >&            \fB(2)\fP            \fI(since C++14)\fP
get( const pair<T1,T2>& p ) noexcept;
template< size_t I, class T1, class T2 >                                                             \fI(since C++11)\fP
typename std::tuple_element<I, std::pair<T1,T2> >::type&&                             \fB(3)\fP            \fI(until C++14)\fP
get( std::pair<T1,T2>&& p ) noexcept;
template< size_t I, class T1, class T2 >
constexpr std::tuple_element_t<I, std::pair<T1,T2> >&&                                \fB(3)\fP            \fI(since C++14)\fP
get( std::pair<T1,T2>&& p ) noexcept;
template< size_t I, class T1, class T2 >                       \fB(1)\fP
constexpr const std::tuple_element_t<I, std::pair<T1,T2> >&&                          \fB(4)\fP            \fI(since C++17)\fP
get( const std::pair<T1,T2>&& p ) noexcept;
template <class T, class U>                                        \fB(2)\fP                \fB(5)\fP            \fI(since C++14)\fP
constexpr T& get(std::pair<T, U>& p) noexcept;
template <class T, class U>                                                           \fB(6)\fP            \fI(since C++14)\fP
constexpr const T& get(const std::pair<T, U>& p) noexcept;             \fB(3)\fP
template <class T, class U>                                                           \fB(7)\fP            \fI(since C++14)\fP
constexpr T&& get(std::pair<T, U>&& p) noexcept;
template <class T, class U>                                                           \fB(8)\fP            \fI(since C++17)\fP
constexpr const T&& get(const std::pair<T, U>&& p) noexcept;
template <class T, class U>                                                           \fB(9)\fP            \fI(since C++14)\fP
constexpr T& get(std::pair<U, T>& p) noexcept;
template <class T, class U>                                                           \fB(10)\fP           \fI(since C++14)\fP
constexpr const T& get(const std::pair<U, T>& p) noexcept;
template <class T, class U>                                                           \fB(11)\fP           \fI(since C++14)\fP
constexpr T&& get(std::pair<U, T>&& p) noexcept;
template <class T, class U>                                                           \fB(12)\fP           \fI(since C++17)\fP
constexpr const T&& get(const std::pair<U, T>&& p) noexcept;

Extracts an element from the pair using tuple-like interface.
The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1.
The type-based overloads (5-12) fail to compile if the types T and U are the same.

.SH Parameters


p - pair whose contents to extract


.SH Return value

1-4) Returns a reference to p.first if I==0 and a reference to p.second if I==1.
5-8) Returns a reference to p.first.
9-12) Returns a reference to p.second.

.SH Example


// Run this code

  #include <iostream>
  #include <utility>

  int main()
  {
      auto p = std::make_pair(1, 3.14);
      std::cout << '(' << std::get<0>(p) << ", " << std::get<1>(p) << ")\\n";
      std::cout << '(' << std::get<int>(p) << ", " << std::get<double>(p) << ")\\n";
  }

.SH Output:

  (1, 3.14)
  (1, 3.14)



.SH See also


                       tuple accesses specified element
std::get(std::tuple)   \fI(function template)\fP
                       accesses an element of an array
std::get(std::array)   \fI(function template)\fP

std::get(std::variant) reads the value of the variant given the index or the type (if the type is unique), throws on error
                       \fI(function template)\fP
\fI(C++17)\fP




