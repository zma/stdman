.TH std::experimental::static_pointer_cast,std::experimental::dynamic_pointer_cast,std::experimental::const_pointer_cast,std::experimental::reinterpret_pointer_cast 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::static_pointer_cast,std::experimental::dynamic_pointer_cast,std::experimental::const_pointer_cast,std::experimental::reinterpret_pointer_cast \- std::experimental::static_pointer_cast,std::experimental::dynamic_pointer_cast,std::experimental::const_pointer_cast,std::experimental::reinterpret_pointer_cast

.SH Synopsis
   template< class T, class U >                                                                                     \fB(1)\fP (library fundamentals TS)
   std::experimental::shared_ptr<T> static_pointer_cast( const std::experimental::shared_ptr<U>& r ) noexcept;
   template< class T, class U >                                                                                     \fB(2)\fP (library fundamentals TS)
   std::experimental::shared_ptr<T> dynamic_pointer_cast( const std::experimental::shared_ptr<U>& r ) noexcept;
   template< class T, class U >                                                                                     \fB(3)\fP (library fundamentals TS)
   std::experimental::shared_ptr<T> const_pointer_cast( const std::experimental::shared_ptr<U>& r ) noexcept;
   template< class T, class U >                                                                                     \fB(4)\fP (library fundamentals TS)
   std::experimental::shared_ptr<T> reinterpret_pointer_cast( const std::experimental::shared_ptr<U>& r ) noexcept;

   Creates a new instance of std::experimental::shared_ptr whose stored pointer is obtained from r's stored pointer using a cast expression. If r is empty, so is the new shared_ptr (but its stored pointer is not necessarily null).

   Otherwise, the new shared_ptr will share ownership with r, except that it is empty if the dynamic_cast performed by dynamic_pointer_cast returns a null pointer.

   Let Y be typename std::experimental::shared_ptr<T>::element_type, then the resulting std::experimental::shared_ptr's stored pointer will be obtained by calling (in respective order):

   1) static_cast<Y*>(r.get()).
   2) dynamic_cast<Y*>(r.get()) (If the result of the dynamic_cast is a null pointer value, the returned shared_ptr will be empty).
   3) const_cast<Y*>(r.get()).
   4) reinterpret_cast<Y*>(r.get()).

   The behavior of these functions is undefined unless the corresponding cast from U* to T* is well formed:

   1) The behavior is undefined unless static_cast<T*>((U*)nullptr) is well formed.
   2) The behavior is undefined unless dynamic_cast<T*>((U*)nullptr) is well formed.
   3) The behavior is undefined unless const_cast<T*>((U*)nullptr) is well formed.
   4) The behavior is undefined unless reinterpret_cast<T*>((U*)nullptr) is well formed.

.SH Parameters

   r - The pointer to convert

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   constructor              constructs new shared_ptr
                            \fI(public member function)\fP
   static_pointer_cast
   dynamic_pointer_cast     applies static_cast, dynamic_cast, const_cast, or reinterpret_cast to the stored pointer
   const_pointer_cast       \fI(function template)\fP
   reinterpret_pointer_cast
   \fI(C++17)\fP
