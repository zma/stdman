.TH std::cbrt,std::cbrtf,std::cbrtl 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::cbrt,std::cbrtf,std::cbrtl \- std::cbrt,std::cbrtf,std::cbrtl

.SH Synopsis

Defined in header <cmath>
float cbrt ( float arg );             \fB(1)\fP \fI(since C++11)\fP
float cbrtf( float arg );
double cbrt ( double arg );           \fB(2)\fP \fI(since C++11)\fP
long double cbrt ( long double arg ); \fB(3)\fP \fI(since C++11)\fP
long double cbrtl( long double arg );
double cbrt ( IntegralType arg );     \fB(4)\fP \fI(since C++11)\fP

1-3) Computes the cubic root of arg.
4) A set of overloads or a function template accepting an argument of any integral_type. Equivalent to 2) (the argument is cast to double).

.SH Parameters


arg - value of a floating-point or Integral_type


.SH Return value

If no errors occur, the cubic root of arg (
3
√
arg), is returned.
If a range error occurs due to underflow, the correct result (after rounding) is returned.

.SH Error handling

Errors are reported as specified in math_errhandling
If the implementation supports IEEE floating-point arithmetic (IEC 60559),

* if the argument is ±0 or ±∞, it is returned, unchanged
* if the argument is NaN, NaN is returned.


.SH Notes

std::cbrt(arg) is not equivalent to std::pow(arg, 1.0/3) because std::pow cannot raise a negative base to a fractional exponent.

.SH Example


// Run this code

  #include <iostream>
  #include <cmath>

  int main()
  {
      // normal use
      std::cout << "cbrt(729) = " << std::cbrt(729) << '\\n'
                << "cbrt(-0.125) = " << std::cbrt(-0.125) << '\\n';
      // special values
      std::cout << "cbrt(-0) = " << std::cbrt(-0.0) << '\\n'
                << "cbrt(+inf) = " << std::cbrt(INFINITY) << '\\n';
  }

.SH Output:

  cbrt(729) = 9
  cbrt(-0.125) = -0.5
  cbrt(-0) = -0
  cbrt(+inf) = inf


.SH See also



pow
powf
powl    raises a number to the given power (xy)
        \fI(function)\fP

\fI(C++11)\fP
\fI(C++11)\fP

sqrt
sqrtf   computes square root (
sqrtl   √
        x)
        \fI(function)\fP
\fI(C++11)\fP
\fI(C++11)\fP

hypot   computes square root of the sum of the squares of two given numbers (
hypotf  √
hypotl  x2
        +y2
\fI(C++11)\fP )
\fI(C++11)\fP \fI(function)\fP
\fI(C++11)\fP




