.TH std::size_t 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::size_t \- std::size_t

.SH Synopsis

  Defined in header <cstddef>
  Defined in header <cstdio>
  Defined in header <cstdlib>
  Defined in header <cstring>
  Defined in header <ctime>
  Defined in header <cwchar>
  typedef /*implementation-defined*/ size_t;

  std::size_t is the unsigned integer type of the result of the sizeof operator
  as well as the sizeof... operator and the alignof operator
  \fI(since C++11)\fP.

.SH Notes

  std::size_t can store the maximum size of a theoretically possible object of any type (including array).
  A type whose size cannot be represented by std::size_t is ill-formed
  \fI(since C++14)\fP On many platforms (an exception is systems with segmented addressing) std::size_t can safely store the value of any non-member pointer, in which case it is synonymous with std::uintptr_t.
  std::size_t is commonly used for array indexing and loop counting. Programs that use other types, such as unsigned int, for array indexing may fail on, e.g. 64-bit systems when the index exceeds UINT_MAX or if it relies on 32-bit modular arithmetic.
  When indexing C++ containers, such as std::string, std::vector, etc, the appropriate type is the member typedef size_type provided by such containers. It is usually defined as a synonym for std::size_t.

.SH Example

  
// Run this code

    #include <cstddef>
    #include <iostream>
    #include <array>

    int main()
    {
        std::array<std::size_t,10> a;
        for (std::size_t i = 0; i != a.size(); ++i)
            a[i] = i;
        for (std::size_t i = a.size()-1; i < a.size(); --i)
            std::cout << a[i] << " ";
    }

.SH Output:

    9 8 7 6 5 4 3 2 1 0


.SH See also


            signed integer type returned when subtracting two pointers
  ptrdiff_t \fI(typedef)\fP
            byte offset from the beginning of a standard-layout type to specified member
  offsetof  \fI(function macro)\fP




