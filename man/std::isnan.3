.TH std::isnan 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::isnan \- std::isnan

.SH Synopsis

Defined in header <cmath>
bool isnan( float arg );        \fB(1)\fP \fI(since C++11)\fP
bool isnan( double arg );       \fB(2)\fP \fI(since C++11)\fP
bool isnan( long double arg );  \fB(3)\fP \fI(since C++11)\fP
bool isnan( IntegralType arg ); \fB(4)\fP \fI(since C++11)\fP

1-3) Determines if the given floating point number arg is a not-a-number (NaN) value.
4) A set of overloads or a function template accepting the arg argument of any integral_type. Equivalent to \fB(2)\fP (the argument is cast to double).

.SH Parameters


arg - floating point value


.SH Return value

true if arg is a NaN, false otherwise

.SH Notes

There are many different NaN values with different sign bits and payloads, see std::nan and std::numeric_limits::quiet_NaN.
NaN values never compare equal to themselves or to other NaN values. Copying a NaN is not required, by IEEE-754, to preserve its bit representation (sign and payload), though most implementation do.
Another way to test if a floating-point value is NaN is to compare it with itself: bool is_nan(double x) { return x != x; }

.SH Example


// Run this code

  #include <iostream>
  #include <cmath>
  #include <cfloat>

  int main()
  {
      std::cout << std::boolalpha
                << "isnan(NaN) = " << std::isnan(NAN) << '\\n'
                << "isnan(Inf) = " << std::isnan(INFINITY) << '\\n'
                << "isnan(0.0) = " << std::isnan(0.0) << '\\n'
                << "isnan(DBL_MIN/2.0) = " << std::isnan(DBL_MIN/2.0) << '\\n'
                << "isnan(0.0 / 0.0)   = " << std::isnan(0.0/0.0) << '\\n'
                << "isnan(Inf - Inf)   = " << std::isnan(INFINITY - INFINITY) << '\\n';
  }

.SH Output:

  isnan(NaN) = true
  isnan(Inf) = false
  isnan(0.0) = false
  isnan(DBL_MIN/2.0) = false
  isnan(0.0 / 0.0)   = true
  isnan(Inf - Inf)   = true


.SH See also



nan
nanf
nanl        not-a-number (NaN)
            \fI(function)\fP
\fI(C++11)\fP
\fI(C++11)\fP
\fI(C++11)\fP

fpclassify  categorizes the given floating point value
            \fI(function)\fP
\fI(C++11)\fP

isfinite    checks if the given number has finite value
            \fI(function)\fP
\fI(C++11)\fP

isinf       checks if the given number is infinite
            \fI(function)\fP
\fI(C++11)\fP

isnormal    checks if the given number is normal
            \fI(function)\fP
\fI(C++11)\fP

isunordered checks if two floating-point values are unordered
            \fI(function)\fP
\fI(C++11)\fP




