.TH std::generate 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::generate \- std::generate

.SH Synopsis

  Defined in header <algorithm>
  template< class ForwardIt, class Generator >                                                     \fI(until C++20)\fP
  void generate( ForwardIt first, ForwardIt last, Generator g );
  template< class ForwardIt, class Generator >                                             \fB(1)\fP     \fI(since C++20)\fP
  constexpr void generate( ForwardIt first, ForwardIt last, Generator g );
  template< class ExecutionPolicy, class ForwardIt, class Generator >                          \fB(2)\fP \fI(since C++17)\fP
  void generate( ExecutionPolicy&& policy, ForwardIt first, ForwardIt last, Generator g );

  1) Assigns each element in range [first, last) a value generated by the given function object g.
  2) Same as \fB(1)\fP, but executed according to policy. This overload only participates in overload resolution if std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is true.

.SH Parameters


  first, last - the range of elements to generate
  policy      - the execution policy to use. See execution_policy for details.
                generator function object that will be called.
                The signature of the function should be equivalent to the following:
  g           -
                Ret fun();

                The type Ret must be such that an object of type ForwardIt can be dereferenced and assigned a value of type Ret. 
.SH Type requirements
  -
  ForwardIt must meet the requirements of LegacyForwardIterator.


.SH Return value

  \fI(none)\fP

.SH Complexity

  Exactly std::distance(first, last) invocations of g() and assignments.

.SH Exceptions

  The overload with a template parameter named ExecutionPolicy reports errors as follows:

  * If execution of a function invoked as part of the algorithm throws an exception and ExecutionPolicy is one of the standard_policies, std::terminate is called. For any other ExecutionPolicy, the behavior is implementation-defined.
  * If the algorithm fails to allocate memory, std::bad_alloc is thrown.


.SH Possible implementation



    template<class ForwardIt, class Generator>
    void generate(ForwardIt first, ForwardIt last, Generator g)
    {
        while (first != last) {
            *first++ = g();
        }
    }



.SH Example

  
// Run this code

    #include <algorithm>
    #include <iostream>
    #include <vector>

    int f()
    {
        static int i = 1;
        return i++;
    }

    int main()
    {
        std::vector<int> v(5);
        std::generate(v.begin(), v.end(), f);

        std::cout << "v: ";
        for (auto iv: v) {
            std::cout << iv << " ";
        }
        std::cout << "\\n";

        // Initialize with default values 0,1,2,3,4 from a lambda function
        // Equivalent to std::iota(v.begin(), v.end(), 0);
        std::generate(v.begin(), v.end(), [n = 0] () mutable { return n++; });

        std::cout << "v: ";
        for (auto iv: v) {
            std::cout << iv << " ";
        }
        std::cout << "\\n";
    }

.SH Output:

    v: 1 2 3 4 5
    v: 0 1 2 3 4


.SH See also


             copy-assigns the given value to every element in a range
  fill       \fI(function template)\fP
             assigns the results of successive function calls to N elements in a range
  generate_n \fI(function template)\fP

  iota       fills a range with successive increments of the starting value
             \fI(function template)\fP
  \fI(C++11)\fP




