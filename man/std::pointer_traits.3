.TH std::pointer_traits 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::pointer_traits \- std::pointer_traits

.SH Synopsis

Defined in header <memory>
template< class Ptr > struct pointer_traits;   \fB(1)\fP \fI(since C++11)\fP
template< class T > struct pointer_traits<T*>; \fB(2)\fP \fI(since C++11)\fP

The pointer_traits class template provides the standardized way to access certain properties of pointer-like types (fancy_pointers, such as boost::interprocess::offset_ptr). The standard template std::allocator_traits relies on pointer_traits to determine the defaults for various typedefs required by Allocator.
1) The non-specialized pointer_traits declares the following types:

.SH Member types


Type            Definition
pointer         Ptr
element_type    Ptr::element_type if present. Otherwise T if Ptr is a template instantiation Template<T, Args...>
difference_type Ptr::difference_type if present, otherwise std::ptrdiff_t


.SH Member alias templates


Template                        Definition
template <class U> using rebind Ptr::rebind<U> if exists, otherwise Template<U, Args...> if Ptr is a template instantiation Template<T, Args...>


.SH Member functions



pointer_to obtains a dereferenceable pointer to its argument
           \fI(public static member function)\fP
\fB[static]\fP

2) A specialization is provided for pointer types, T*, which declares the following types

.SH Member types


Type            Definition
pointer         T*
element_type    T
difference_type std::ptrdiff_t


.SH Member alias templates


Template                         Definition
template< class U > using rebind U*


.SH Member functions



pointer_to obtains a dereferenceable pointer to its argument
           \fI(public static member function)\fP
\fB[static]\fP

3) A specialization for user-defined fancy pointer types may define an additional static member function

Optional Member functions



to_address       obtains a raw pointer from a fancy pointer (inverse of pointer_to)
                 \fI(public static member function)\fP
\fB[static]\fP (C++20)


.SH Notes

The rebind member template alias makes it possible, given a pointer-like type that points to T, to obtain the same pointer-like type that points to U. For example,

  using another_pointer = std::pointer_traits<std::shared_ptr<int>>::rebind<double>;
  static_assert(std::is_same<another_pointer, std::shared_ptr<double>>::value);


.SH Example


// Run this code

  #include <memory>
  #include <iostream>

  template <class Ptr>
  struct BlockList
  {
     // Predefine a memory block
     struct block;

     // Define a pointer to a memory block from the kind of pointer Ptr s
     // If Ptr is any kind of T*, block_ptr_t is block*
     // If Ptr is smart_ptr<T>, block_ptr_t is smart_ptr<block>
     using block_ptr_t = typename std::pointer_traits<Ptr>::template rebind<block>;

     struct block
     {
        std::size_t size;
        block_ptr_t next_block;
     };

     block_ptr_t free_blocks;
  };

  int main()
  {
      BlockList<int*> bl1;
      // The type of bl1.free_blocks is block*

      BlockList<std::shared_ptr<char>> bl2;
      // The type of bl2.free_blocks is std::shared_ptr<block>
      std::cout << bl2.free_blocks.use_count() << '\\n';
  }

.SH Output:

  0


.SH See also



allocator_traits provides information about allocator types
                 \fI(class template)\fP
\fI(C++11)\fP

addressof        obtains actual address of an object, even if the & operator is overloaded
                 \fI(function template)\fP
\fI(C++11)\fP




