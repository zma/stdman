.TH std::atomic_ref<T>::fetch_add 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::atomic_ref<T>::fetch_add \- std::atomic_ref<T>::fetch_add

.SH Synopsis
   member only of atomic_ref<Integral> and atomic_ref<Floating> template specializations
   T fetch_add( T arg,                                                                   \fB(1)\fP
   std::memory_order order = std::memory_order_seq_cst ) const noexcept;
   member only of atomic_ref<T*> template specialization
   T* fetch_add( std::ptrdiff_t arg,                                                     \fB(2)\fP
   std::memory_order order = std::memory_order_seq_cst ) const noexcept;

   Atomically replaces the current value of the referenced object with the result of arithmetic addition of the value and arg. This operation is a read-modify-write operation. Memory is affected according to the value of order.

   For signed integral types, arithmetic is defined to use twoâ€™s complement representation. There are no undefined results.

   For floating-point types, the floating-point environment in effect may be different from the calling thread's floating-point environment. The operation need not be conform to the corresponding std::numeric_limits traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.

   For T* types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if T is not an object type.

.SH Parameters

   arg   - the other argument of arithmetic addition
   order - memory order constraints to enforce

.SH Return value

   The value of the referenced object, immediately preceding the effects of this function.

.SH Example

    This section is incomplete
    Reason: no example
