.TH std::swap 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::swap \- std::swap

.SH Synopsis

Defined in header <algorithm>                                               \fI(until C++11)\fP
Defined in header <utility>                                                 \fI(since C++11)\fP
template< class T >                                                                       \fI(until C++11)\fP
void swap( T& a, T& b );
template< class T >                                                                       \fI(since C++11)\fP
void swap( T& a, T& b ) noexcept(/* see below */);                                        \fI(until C++20)\fP
template< class T >                                                     \fB(1)\fP               \fI(since C++20)\fP
constexpr void swap( T& a, T& b ) noexcept(/* see below */);
template< class T2, std::size_t N >                                                                      \fI(since C++11)\fP
void swap( T2 (&a)[N], T2 (&b)[N]) noexcept(/* see below */);               \fB(2)\fP                          \fI(until C++20)\fP
template< class T2, std::size_t N >                                                                      \fI(since C++20)\fP
constexpr void swap( T2 (&a)[N], T2 (&b)[N]) noexcept(/* see below */);

Exchanges the given values.
1) Swaps the values a and b.
This overload does not participate in overload resolution unless std::is_move_constructible_v<T> && std::is_move_assignable_v<T> is true.
\fI(since C++17)\fP
2) Swaps the arrays a and b. In effect calls std::swap_ranges(a, a+N, b).
This overload does not participate in overload resolution unless std::is_swappable_v<T2> is true.
\fI(since C++17)\fP

.SH Parameters


a, b - the values to be swapped
.SH Type requirements
-
T must meet the requirements of MoveAssignable and MoveConstructible.
-
T2 must meet the requirements of Swappable.


.SH Return value

\fI(none)\fP

.SH Exceptions

1)

\fI(none)\fP                                          \fI(until C++11)\fP
noexcept specification:
noexcept(
std::is_nothrow_move_constructible<T>::value && \fI(since C++11)\fP
std::is_nothrow_move_assignable<T>::value
)

2)

noexcept specification:
noexcept(noexcept(swap(*a, *b)))                                                                                                                                                                                                          \fI(until C++17)\fP
The lookup for the identifier swap in the exception specification finds this function template in addition to anything found by the usual lookup rules, making the exception specification equivalent to C++17 std::is_nothrow_swappable.
noexcept specification:                                                                                                                                                                                                                   \fI(since C++17)\fP
noexcept(std::is_nothrow_swappable_v<T2>)


.SH Complexity

1) Constant
2) Linear in N

.SH Specializations


std::swap may be specialized_in_namespace_std for program-defined types, but such specializations are not found by ADL (the namespace std is not the associated namespace for the program-defined type). \fI(until C++20)\fP

The expected way to make a program-defined type swappable is to provide a non-member function swap in the same namespace as the type: see Swappable for details.
The following overloads are already provided by the standard library:


std::swap(std::pair)                specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::tuple)               specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::shared_ptr)          specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::weak_ptr)            specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::unique_ptr)          specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::function)            specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP
                                    specializes the std::swap algorithm
std::swap(std::basic_string)        \fI(function template)\fP

std::swap(std::array)               specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP
                                    specializes the std::swap algorithm
std::swap(std::deque)               \fI(function template)\fP

std::swap(std::forward_list)        specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP
                                    specializes the std::swap algorithm
std::swap(std::list)                \fI(function template)\fP
                                    specializes the std::swap algorithm
std::swap(std::vector)              \fI(function template)\fP
                                    specializes the std::swap algorithm
std::swap(std::map)                 \fI(function template)\fP
                                    specializes the std::swap algorithm
std::swap(std::multimap)            \fI(function template)\fP
                                    specializes the std::swap algorithm
std::swap(std::set)                 \fI(function template)\fP
                                    specializes the std::swap algorithm
std::swap(std::multiset)            \fI(function template)\fP

std::swap(std::unordered_map)       specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::unordered_multimap)  specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::unordered_set)       specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::unordered_multiset)  specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP
                                    specializes the std::swap algorithm
std::swap(std::queue)               \fI(function template)\fP
                                    specializes the std::swap algorithm
std::swap(std::priority_queue)      \fI(function template)\fP
                                    specializes the std::swap algorithm
std::swap(std::stack)               \fI(function template)\fP

std::swap(std::valarray)            specializes the std::swap() algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::basic_stringbuf)     specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::basic_istringstream) specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::basic_ostringstream) specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::basic_stringstream)  specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::basic_filebuf)       specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::basic_ifstream)      specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::basic_ofstream)      specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::basic_fstream)       specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::basic_syncbuf)       specializes the std::swap algorithm
                                    \fI(function template)\fP
(C++20)

std::swap(std::basic_regex)         specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::match_results)       specializes the std::swap() algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::thread)              specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::unique_lock)         specialization of std::swap for unique_lock
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::promise)             specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::packaged_task)       specializes the std::swap algorithm
                                    \fI(function template)\fP
\fI(C++11)\fP

std::swap(std::optional)            specializes the std::swap algorithm
                                    \fI(function)\fP
\fI(C++17)\fP

std::swap(std::any)                 specializes the std::swap algorithm
                                    \fI(function)\fP
\fI(C++17)\fP

std::swap(std::variant)             specializes the std::swap algorithm
                                    \fI(function)\fP
\fI(C++17)\fP
                                    swaps two paths
swap(std::filesystem::path)         \fI(function)\fP


.SH Example


// Run this code

  #include <algorithm>
  #include <iostream>

  int main()
  {
     int a = 5, b = 3;

     // before
     std::cout << a << ' ' << b << '\\n';

     std::swap(a,b);

     // after
     std::cout << a << ' ' << b << '\\n';
  }

.SH Output:

  5 3
  3 5


Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.

DR       Applied to Behavior as published                                                               Correct behavior
LWG_2554 C++11      swapping multi-dimensional arrays can never be noexcept due to name lookup problems made to work


.SH See also


            swaps the elements pointed to by two iterators
iter_swap   \fI(function template)\fP
            swaps two ranges of elements
swap_ranges \fI(function template)\fP

exchange    replaces the argument with a new value and returns its previous value
            \fI(function template)\fP
\fI(C++14)\fP




