.TH std::min 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::min \- std::min

.SH Synopsis

  Defined in header <algorithm>
  template< class T >                                                      \fI(until C++14)\fP
  const T& min( const T& a, const T& b );
  template< class T >                                                      \fI(since C++14)\fP
  constexpr const T& min( const T& a, const T& b );
  template< class T, class Compare >                                                     \fI(until C++14)\fP
  const T& min( const T& a, const T& b, Compare comp );
  template< class T, class Compare >                                                     \fI(since C++14)\fP
  constexpr const T& min( const T& a, const T& b, Compare comp );  \fB(1)\fP
  template< class T >                                                                                  \fI(since C++11)\fP
  T min( std::initializer_list<T> ilist );                             \fB(2)\fP                             \fI(until C++14)\fP
  template< class T >                                                                                  \fI(since C++14)\fP
  constexpr T min( std::initializer_list<T> ilist );                       \fB(3)\fP
  template< class T, class Compare >                                                                                  \fI(since C++11)\fP
  T min( std::initializer_list<T> ilist, Compare comp );                                 \fB(4)\fP                          \fI(until C++14)\fP
  template< class T, class Compare >                                                                                  \fI(since C++14)\fP
  constexpr T min( std::initializer_list<T> ilist, Compare comp );

  Returns the smaller of the given values.
  1-2) Returns the smaller of a and b.
  3-4) Returns the smallest of the values in initializer list ilist.
  The (1,3) versions use operator< to compare the values, the (2,4) versions use the given comparison function comp.

.SH Parameters


  a, b  - the values to compare
  ilist - initializer list with the values to compare
          comparison function object (i.e. an object that satisfies the requirements of Compare) which returns true if a is less than b.
          The signature of the comparison function should be equivalent to the following:
          bool cmp(const Type1 &a, const Type2 &b);
  cmp   - While the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value_category (thus, Type1 & is not allowed
          , nor is Type1 unless for Type1 a move is equivalent to a copy
          \fI(since C++11)\fP).
          The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both of them. 
.SH Type requirements
  -
  T must meet the requirements of LessThanComparable in order to use overloads (1,3).
  -
  T must meet the requirements of CopyConstructible in order to use overloads (3,4).


.SH Return value

  1-2) The smaller of a and b. If the values are equivalent, returns a.
  3-4) The smallest value in ilist. If several values are equivalent to the smallest, returns the leftmost such value.

.SH Complexity

  1-2) Exactly one comparison
  3-4) Exactly ilist.size() - 1 comparisons

.SH Possible implementation


.SH First version

    template<class T>
    const T& min(const T& a, const T& b)
    {
        return (b < a) ? b : a;
    }

.SH Second version

    template<class T, class Compare>
    const T& min(const T& a, const T& b, Compare comp)
    {
        return (comp(b, a)) ? b : a;
    }

  Third version

    template<class T>
    T min( std::initializer_list<T> ilist)
    {
        return *std::min_element(ilist.begin(), ilist.end());
    }

  Fourth version

    template<class T, class Compare>
    T min(std::initializer_list<T> ilist, Compare comp)
    {
        return *std::min_element(ilist.begin(), ilist.end(), comp);
    }



  Warning

  Capturing the result of std::min by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:

    int n = 1;
    const int& r = std::min(n-1, n+1);
    // r is dangling


.SH Example

  
// Run this code

    #include <algorithm>
    #include <iostream>
    #include <string>

    int main()
    {
        std::cout << "smaller of 1 and 9999: " << std::min(1, 9999) << '\\n'
                  << "smaller of 'a', and 'b': " << std::min('a', 'b') << '\\n'
                  << "shortest of \\"foo\\", \\"bar\\", and \\"hello\\": " <<
                      std::min( { "foo", "bar", "hello" },
                                [](const std::string& s1, const std::string& s2) {
                                     return s1.size() < s2.size();
                                 }) << '\\n';
    }

.SH Output:

    smaller of 1 and 9999: 1
    smaller of 'a', and 'b': a
    shortest of "foo", "bar", and "hello": foo


.SH See also


              returns the greater of the given values
  max         \fI(function template)\fP

  minmax      returns the smaller and larger of two elements
              \fI(function template)\fP
  \fI(C++11)\fP
              returns the smallest element in a range
  min_element \fI(function template)\fP




