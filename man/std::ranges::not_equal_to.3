.TH std::ranges::not_equal_to 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::not_equal_to \- std::ranges::not_equal_to

.SH Synopsis

Defined in header <functional>
struct not_equal_to;            \fI(since C++20)\fP

Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type).

.SH Member types


Member type    Definition
is_transparent /* unspecified */


.SH Member functions


           checks if the arguments are not equal
operator() \fI(public member function)\fP


std::ranges::not_equal_to::operator()


template< class T, class U >
requires EqualityComparableWith<T, U> ||
/* std::declval<T>() == std::declval<U>() resolves to
a built-in operator comparing pointers */
constexpr bool operator()(T&& t, U&& u) const;

Compares t and u. Equivalent to return !ranges::equal_to{}(std::forward<T>(t), std::forward<U>(u));.

.SH Notes

Unlike std::not_equal_to, std::ranges::not_equal_to requires both == and != to be valid (via the EqualityComparableWith constraint), and is entirely defined in terms of std::ranges::equal_to. However, the implementation is free to use operator!= directly, because those concepts require the results of == and != to be consistent.

.SH Example


 This section is incomplete
 Reason: no example


.SH See also


             function object implementing x != y
not_equal_to \fI(class template)\fP




