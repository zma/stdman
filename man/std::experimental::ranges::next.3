.TH std::experimental::ranges::next 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::ranges::next \- std::experimental::ranges::next

.SH Synopsis
   Defined in header <experimental/ranges/iterator>
   namespace {
                                                                       (ranges TS)
   constexpr /* unspecified */ next = /* unspecified */;               (customization point object)

   }
   Call signature
   template< Iterator I >                                          \fB(1)\fP
   constexpr I next(I i);
   template< Iterator I >                                          \fB(2)\fP
   constexpr I next(I i, ranges::difference_type_t<I> n);
   template< Iterator I, Sentinel<I> S >                           \fB(3)\fP
   constexpr I next(I i, S bound);
   template< Iterator I, Sentinel<I> S >                           \fB(4)\fP
   constexpr I next(I i, ranges::difference_type_t<I> n, S bound);

   Advances the iterator i n times, or until bound is reached, whichever comes first, and returns the advanced iterator.

   1) Equivalent to ++i; return i;.
   2) Equivalent to ranges::advance(i, n); return i;.
   3) Equivalent to ranges::advance(i, bound); return i;.
   4) Equivalent to ranges::advance(i, n, bound); return i;.

  Customization point objects

   The name ranges::next denotes a customization point object, which is a function object of a literal Semiregular class type (denoted, for exposition purposes, as NextT). All instances of NextT are equal. Thus, ranges::next can be copied freely and its copies can be used interchangeably.

   Given a set of types Args..., if std::declval<Args>()... meet the requirements for arguments to ranges::next above, NextT will satisfy ranges::Invocable<const NextT, Args...>. Otherwise, no function call operator of NextT participates in overload resolution.

   In every translation unit in which ranges::next is defined, it refers to the same instance of the customization point object. (This means that it can be used freely in things like inline functions and function templates without violating the one-definition rule.)

.SH Return value

   The advanced iterator.

.SH Notes

   Even though omitting n for overload \fB(2)\fP behaves as if n is 1, omitting n for overload \fB(4)\fP effectively behaves as if n is infinity (always advance to bound).

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   next     increment an iterator
   \fI(C++11)\fP  \fI(function template)\fP
   advance  advances an iterator by given distance
            \fI(function template)\fP
   prev     decrement an iterator
            \fI(function template)\fP
   distance returns the distance between an iterator and a sentinel, or between the beginning and the end of a range
            \fI(function template)\fP
