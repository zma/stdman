.TH std::experimental::weak_ptr<T>::weak_ptr 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::weak_ptr<T>::weak_ptr \- std::experimental::weak_ptr<T>::weak_ptr

.SH Synopsis

constexpr weak_ptr() noexcept;                                  \fB(1)\fP (library fundamentals TS)
weak_ptr( const weak_ptr& r ) noexcept;                         \fB(2)\fP (library fundamentals TS)
template< class Y >                                             \fB(2)\fP (library fundamentals TS)
weak_ptr( const weak_ptr<Y>& r ) noexcept;
template< class Y >                                             \fB(2)\fP (library fundamentals TS)
weak_ptr( const std::experimental::shared_ptr<Y>& r ) noexcept;
weak_ptr( weak_ptr&& r ) noexcept;                              \fB(3)\fP (library fundamentals TS)
template< class Y >                                             \fB(3)\fP (library fundamentals TS)
weak_ptr( weak_ptr<Y>&& r ) noexcept;

Constructs a new weak_ptr that potentially shares an object with r.
1) Default constructor. Constructs empty weak_ptr.
2) Constructs new weak_ptr which shares an object managed by r. If r manages no object, *this manages no object too. The templated overloads don't participate in overload resolution unless either Y* is implicitly convertible to T*, or Y is the type "array of N U" for some type U and some number N, and T is the type "array of unknown bound of (possibly cv-qualified) U".
3) Move constructors. Moves a weak_ptr instance from r into *this. After this, r is empty and r.use_count()==0. The templated overload doesn't participate in overload resolution unless either Y* is implicitly convertible to T*, or Y is the type "array of N U" for some type U and some number N, and T is the type "array of unknown bound of (possibly cv-qualified) U".

.SH Parameters


r - a std::experimental::shared_ptr or std::experimental::weak_ptr that will be viewed by this std::experimental::weak_ptr


.SH Exceptions

noexcept specification:
noexcept

.SH Example


 This section is incomplete
 Reason: no example


.SH See also


              creates a new weak_ptr
constructor   \fI(public member function of std::weak_ptr<T>)\fP
              assigns the weak_ptr
operator=     \fI(public member function of std::weak_ptr<T>)\fP




