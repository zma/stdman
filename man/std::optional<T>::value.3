.TH std::optional<T>::value 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::optional<T>::value \- std::optional<T>::value

.SH Synopsis

  constexpr T& value() &;               \fB(1)\fP \fI(since C++17)\fP
  constexpr const T & value() const &;
  constexpr T&& value() &&;             \fB(2)\fP \fI(since C++17)\fP
  constexpr const T&& value() const &&;

  If *this contains a value, returns a reference to the contained value.
  Otherwise, throws a std::bad_optional_access exception.

.SH Parameters

  \fI(none)\fP

.SH Return value

  A reference to the contained value.

.SH Exceptions

  std::bad_optional_access if *this does not contain a value.

.SH Notes

  The dereference operator operator*() does not check if this optional contains a value, which may be more efficient than value().

.SH Example

  
// Run this code

    #include <optional>
    #include <iostream>
    int main()
    {
        std::optional<int> opt = {};

        try {
            int n = opt.value();
        } catch(const std::bad_optional_access& e) {
            std::cout << e.what() << '\\n';
        }
    }

.SH Possible output:

    bad optional access


.SH See also


                      returns the contained value if available, another value otherwise
  value_or            \fI(public member function)\fP
                      accesses the contained value
  operator->          \fI(public member function)\fP
  operator*

  bad_optional_access exception indicating checked access to an optional that doesn't contain a value
                      \fI(class)\fP
  \fI(C++17)\fP




