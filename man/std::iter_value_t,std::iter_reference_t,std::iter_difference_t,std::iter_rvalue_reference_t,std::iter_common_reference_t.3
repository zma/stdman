.TH std::iter_value_t,std::iter_reference_t,std::iter_difference_t,std::iter_rvalue_reference_t,std::iter_common_reference_t 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::iter_value_t,std::iter_reference_t,std::iter_difference_t,std::iter_rvalue_reference_t,std::iter_common_reference_t \- std::iter_value_t,std::iter_reference_t,std::iter_difference_t,std::iter_rvalue_reference_t,std::iter_common_reference_t

.SH Synopsis

Defined in header <iterator>
template< class T >
concept /*dereferenceable*/ = /* see below */; // exposition only
template< class T >                                                               \fB(1)\fP \fI(since C++20)\fP
using iter_value_t = /* see below */;
template< /*dereferenceable*/ T >                                                 \fB(2)\fP \fI(since C++20)\fP
using iter_reference_t = decltype(*std::declval<T&>());
template< class T >                                                               \fB(3)\fP \fI(since C++20)\fP
using iter_difference_t = /* see below */;
template< /*dereferenceable*/ T>
requires /* see below */                                                          \fB(4)\fP \fI(since C++20)\fP
using iter_rvalue_reference_t = decltype(ranges::iter_move(std::declval<T&>()));
template< Readable T >
using iter_common_reference_t = std::common_reference_t<std::iter_reference_t<T>, \fB(5)\fP \fI(since C++20)\fP
std::iter_value_t<T>&>;

Compute the associated types of an iterator. The exposition-only concept dereferenceable is satisfied if and only if the expression *std::declval<T&>() is valid and has a referenceable type (in particular, not void).
1) Computes the value type of T. If std::iterator_traits<T> is not specialized, then std::iter_value_t<T> is std::readable_traits<T>::value_type. Otherwise, it is std::iterator_traits<T>::value_type.
2) Computes the reference type of T.
3) Computes the difference type of T. If std::iterator_traits<T> is not specialized, then std::iter_difference_t<T> is std::incrementable_traits<T>::difference_type. Otherwise, it is std::iterator_traits<T>::difference_type.
4) Computes the rvalue reference type of T. The "see below" portion of the constraint on this alias template is satisfied if and only if the expression ranges::iter_move(std::declval<T&>()) is valid and has a referenceable type (in particular, not void).
5) Computes the common reference type of T. This is the common reference type between its reference type and an lvalue reference to its value type.

.SH See also


                     specifies that a type is readable by applying operator *
Readable             (concept)
                     specifies that a Semiregular type can be incremented with pre- and post-increment operators
WeaklyIncrementable  (concept)
                     computes the value type of a Readable type
readable_traits      \fI(class template)\fP
                     computes the difference type of a WeaklyIncrementable type
incrementable_traits \fI(class template)\fP
                     provides uniform interface to the properties of an iterator
iterator_traits      \fI(class template)\fP




