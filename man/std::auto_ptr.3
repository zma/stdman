.TH std::auto_ptr 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::auto_ptr \- std::auto_ptr

.SH Synopsis

  Defined in header <memory>
  template< class T > class auto_ptr; \fB(1)\fP (deprecated in C++11)
                                          (removed in C++17)
  template<> class auto_ptr<void>;    \fB(2)\fP (deprecated in C++11)
                                          (removed in C++17)

  auto_ptr is a smart pointer that manages an object obtained via new_expression and deletes that object when auto_ptr itself is destroyed. It may be used to provide exception safety for dynamically-allocated objects, for passing ownership of dynamically-allocated objects into functions and for returning dynamically-allocated objects from functions.
  Copying an auto_ptr copies the pointer and transfers ownership to the destination: both copy construction and copy assignment of auto_ptr modify their right hand arguments, and the "copy" is not equal to the original. Because of these unusual copy semantics, auto_ptr may not be placed in standard containers.
  std::unique_ptr is preferred for this and other uses.
  \fI(since C++11)\fP
  2) Specialization for type void is provided, it declares the typedef element_type, but no member functions.
  An additional class template auto_ptr_ref is referred to throughout the documentation. It is an implementation-defined type that holds a reference to auto_ptr. The implementation is allowed to provide the template with a different name or implement the functions returning it or accepting it as parameter in other ways.

.SH Member types


  Member type  Definition
  element_type T


.SH Member functions


                           creates a new auto_ptr
  constructor              \fI(public member function)\fP
                           destroys an auto_ptr and the managed object
  destructor               \fI(public member function)\fP
                           transfers ownership from another auto_ptr
  operator=                \fI(public member function)\fP
                           converts the managed pointer to a pointer to different type
  operator_auto_ptr<Y>     \fI(public member function)\fP
  operator_auto_ptr_ref<Y>

.SH Observers

                           returns a pointer to the managed object
  get                      \fI(public member function)\fP
                           accesses the managed object
  operator*                \fI(public member function)\fP
  operator->

.SH Modifiers

                           destroys the managed object
  reset                    \fI(public member function)\fP
                           releases ownership of the managed object
  release                  \fI(public member function)\fP




