.TH std::bitset<N>::operator<<,<<=,>>,>>= 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::bitset<N>::operator<<,<<=,>>,>>= \- std::bitset<N>::operator<<,<<=,>>,>>=

.SH Synopsis

  bitset<N> operator<<( std::size_t pos ) const; \fB(1)\fP
  bitset<N>& operator<<=( std::size_t pos );     \fB(2)\fP
  bitset<N> operator>>( std::size_t pos ) const; \fB(3)\fP
  bitset<N>& operator>>=( std::size_t pos );     \fB(4)\fP

  Performs binary shift left and binary shift right. Zeroes are shifted in.
  1-2) Performs binary shift left. The \fB(2)\fP version is destructive, i.e. performs the shift to the current object.
  3-4) Performs binary shift right. The \fB(4)\fP version is destructive, i.e. performs the shift to the current object.

.SH Parameters


  pos - number of positions to shift the bits


.SH Return value

  1,3) new bitset object containing the shifted bits
  2,4) *this

.SH Exceptions


  \fI(none)\fP                  \fI(until C++11)\fP
  noexcept specification: \fI(since C++11)\fP
  noexcept


.SH Example

  
// Run this code

    #include <iostream>
    #include <bitset>

    int main()
    {
        std::bitset<8> b("01110010");
        std::cout << "initial value: " << b << '\\n';

        while (b.any()) {
            while (!b.test(0)) {
                b >>= 1;
            }
            std::cout << b << '\\n';
            b >>= 1;
        }
    }

.SH Output:

    initial value: 01110010
    00111001
    00000111
    00000011
    00000001


.SH See also



  operator&= performs binary AND, OR, XOR and NOT
  operator|= \fI(public member function)\fP
  operator^=
  operator~




