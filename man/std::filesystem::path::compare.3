.TH std::filesystem::path::compare 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::filesystem::path::compare \- std::filesystem::path::compare

.SH Synopsis

int compare( const path& p ) const noexcept;                 \fB(1)\fP \fI(since C++17)\fP
int compare( const string_type& str ) const;                 \fB(2)\fP \fI(since C++17)\fP
int compare( std::basic_string_view<value_type> str ) const;
int compare( const value_type* s ) const;                    \fB(3)\fP \fI(since C++17)\fP

Compares the lexical representations of the path and another path.
1) If root_name().native().compare(p.root_name().native()) is nonzero, returns that value.
Otherwise, if has_root_directory() != p.has_root_directory(), returns a value less than zero if has_root_directory() is false and a value greater than zero otherwise.
Otherwise returns a value less than, equal to or greater than 0 if the relative portion of the path (relative_path()) is respectively lexicographically less than, equal to or greater than the relative portion of p (p.relative_path()). Comparison is performed element-wise, as if by iterating both paths from begin() to end() and comparing the result of native() for each element.
2) Equivalent to compare(path(str)).
3) Equivalent to compare(path(s)).

.SH Parameters


p   - a path to compare to
str - a string or string view representing path to compare to
s   - a null-terminated string representing path to compare to


.SH Return value

A value less than 0 if the path is lexicographically less than the given path.
A value equal to 0 if the path is lexicographically equal to the given path.
A value greater than 0 if the path is lexicographically greater than the given path.

.SH Exceptions

2-3) \fI(none)\fP

.SH Notes

For two-way comparisons, binary_operators may be more suitable.

.SH Example


// Run this code

  #include <iostream>
  #include <filesystem>
  namespace fs = std::filesystem;
  void demo(int rc, fs::path p1, fs::path p2) {
      if(rc < 0) std::cout << p1 << " < " << p2 << '\\n';
      else if(rc > 0) std::cout << p1 << " > "  << p2 << '\\n';
      else if(rc == 0) std::cout << p1 << "==" << p2 << '\\n';
  }
  int main() {
      fs::path p1 = "/a/b/"; // as if "a/b/." for lexicographical iteration
      fs::path p2 = "/a/b/#";
      demo(p1.compare(p2), p1, p2);
      demo(p1.compare("a/b/_"), p1, "a/b/_");
  }

.SH Output:

  "/a/b/" > "/a/b/#"
  "/a/b/" < "a/b/_"


Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.

DR       Applied to Behavior as published               Correct behavior
LWG_2936 C++17      compared all path elements directly root name and root directory handled separately


.SH See also



operator==
operator!= lexicographically compares two paths
operator<  \fI(function)\fP
operator<=
operator>
operator>=




