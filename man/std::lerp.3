.TH std::lerp 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::lerp \- std::lerp

.SH Synopsis

Defined in header <cmath>
constexpr float lerp( float a, float b, float t );                         \fB(1)\fP \fI(since C++20)\fP
constexpr double lerp( double a, double b, double t );                     \fB(2)\fP \fI(since C++20)\fP
constexpr long double lerp( long double a, long double b, long double t ); \fB(3)\fP \fI(since C++20)\fP
constexpr Promoted lerp( Arithmetic1 a, Arithmetic2 b, Arithmetic3 t );    \fB(4)\fP \fI(since C++20)\fP

1-3) Computes a+t*(b−a), i.e. the linear interpolation between a and b for the parameter t (or extrapolation, when t is outside the range [0,1]).
4) A set of overloads or a function template for all combinations of arguments of arithmetic_type not covered by 1-3). If any argument has integral_type, it is cast to double. If any other argument is long double, then the return type is long double, otherwise it is double.

.SH Parameters


a, b, t - values of floating-point or integral_types


.SH Return value

a+t*(b−a)
When isfinite(a) && isfinite(b), the following properties are guaranteed:

* If t == 0, the result is equal to a.
* If t == 1, the result is equal to b.
* If t >= 0 && t <= 1, the result is finite.
* If isfinite(t) && a == b, the result is equal to a.
* If isfinite(t) || (!isnan(t) && b-a != 0), the result is not NaN.

Let CMP(x,y) be 1 if x > y, -1 if x < y, and 0 otherwise. For any t1 and t2, the product of CMP(lerp(a, b, t2), lerp(a, b, t1)), CMP(t2, t1), and CMP(b, a) is non-negative. (That is, lerp is monotonic.)

.SH Examples


 This section is incomplete
 Reason: no example




