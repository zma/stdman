.TH std::experimental::optional<T>::operator->,std::experimental::optional<T>::operator* 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::optional<T>::operator->,std::experimental::optional<T>::operator* \- std::experimental::optional<T>::operator->,std::experimental::optional<T>::operator*

.SH Synopsis

constexpr const T* operator->() const;   \fB(1)\fP (library fundamentals TS)
constexpr T* operator->();               \fB(1)\fP (library fundamentals TS)
constexpr const T& operator*() const&;   \fB(2)\fP (library fundamentals TS)
constexpr T& operator*() &;              \fB(2)\fP (library fundamentals TS)
constexpr const T&& operator*() const&&; \fB(2)\fP (library fundamentals TS)
constexpr T&& operator*() &&;            \fB(2)\fP (library fundamentals TS)

Accesses the contained value.
1) Returns a pointer to the contained value.
2) Returns a reference to the contained value.
The behavior is undefined if *this does not contain a value

.SH Parameters

\fI(none)\fP

.SH Return value

Pointer or reference to the contained value.

.SH Exceptions

\fI(none)\fP

.SH Notes

This operator does not check whether the optional contains a value. If checked access is needed, value() or value_or() may be used.

.SH Example


// Run this code

  #include <experimental/optional>
  #include <iostream>
  #include <string>
  using namespace std::literals;
  int main()
  {
      std::experimental::optional<int> opt1 = 1;
      std::cout << *opt1 << '\\n';

      std::experimental::optional<std::string> opt2 = "abc"s;
      std::cout << opt2->size() << '\\n';
  }

.SH Output:

  1
  3


.SH See also


         returns the contained value
value    \fI(public member function)\fP
         returns the contained value if available, another value otherwise
value_or \fI(public member function)\fP




