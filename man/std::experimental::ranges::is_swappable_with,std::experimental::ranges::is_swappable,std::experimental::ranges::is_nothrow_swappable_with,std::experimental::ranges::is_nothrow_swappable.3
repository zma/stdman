.TH std::experimental::ranges::is_swappable_with,std::experimental::ranges::is_swappable,std::experimental::ranges::is_nothrow_swappable_with,std::experimental::ranges::is_nothrow_swappable 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::ranges::is_swappable_with,std::experimental::ranges::is_swappable,std::experimental::ranges::is_nothrow_swappable_with,std::experimental::ranges::is_nothrow_swappable \- std::experimental::ranges::is_swappable_with,std::experimental::ranges::is_swappable,std::experimental::ranges::is_nothrow_swappable_with,std::experimental::ranges::is_nothrow_swappable

.SH Synopsis

Defined in header <experimental/ranges/type_traits>
template <class T, class U>                         \fB(1)\fP (ranges TS)
struct is_swappable_with;
template <class T>                                  \fB(2)\fP (ranges TS)
struct is_swappable;
template <class T, class U>                         \fB(3)\fP (ranges TS)
struct is_nothrow_swappable_with;
template <class T>                                  \fB(4)\fP (ranges TS)
struct is_nothrow_swappable;

1) If the expressions ranges::swap(std::declval<T>(), std::declval<U>()) and ranges::swap(std::declval<U>(), std::declval<T>()) are both well-formed when treated as an unevaluated operand, provides the member constant value equal true. Otherwise, value is false. Access_checks are performed as if from a context unrelated to either type.
2) If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to ranges::is_swappable_with<T&, T&>::value.
3) Same as \fB(1)\fP, but evaluations of both expressions from (1) are known not to throw exceptions.
4) Same as \fB(2)\fP, but uses is_nothrow_swappable_with.
T and U shall each be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.

Helper variable templates


template <class T, class U>                                                          \fB(1)\fP (ranges TS)
constexpr bool is_swappable_with_v = is_swappable_with<T, U>::value;
template <class T>                                                                   \fB(2)\fP (ranges TS)
constexpr bool is_swappable_v = is_swappable<T>::value;
template <class T, class U>                                                          \fB(3)\fP (ranges TS)
constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<T, U>::value;
template <class T>                                                                   \fB(4)\fP (ranges TS)
constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<T>::value;


Inherited from std::integral_constant


.SH Member constants



value    true if T is swappable with U , false otherwise
         \fI(public static member constant)\fP
\fB[static]\fP


.SH Member functions


              converts the object to bool, returns value
operator bool \fI(public member function)\fP

operator()    returns value
              \fI(public member function)\fP
\fI(C++14)\fP


.SH Member types


Type       Definition
value_type bool
type       std::integral_constant<bool, value>


.SH Notes

This trait does not check anything outside the immediate context of the swap expressions: if the use of T or U would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual swap may not compile even if ranges::is_swappable_with<T,U>::value compiles and evaluates to true.

.SH Examples


 This section is incomplete
 Reason: no example


.SH See also


                          specifies that a type can be swapped or that two types can be swapped with each other
Swappable                 (concept)
SwappableWith

is_swappable_with
is_swappable
is_nothrow_swappable_with
is_nothrow_swappable      checks if objects of a type can be swapped with objects of same or different type
                          \fI(class template)\fP
\fI(C++17)\fP
\fI(C++17)\fP
\fI(C++17)\fP
\fI(C++17)\fP




