.TH std::variant<Types...>::emplace 3 "2020.03.24" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::variant<Types...>::emplace \- std::variant<Types...>::emplace

.SH Synopsis

template <class T, class... Args>                                                             \fB(1)\fP \fI(since C++17)\fP
T& emplace(Args&&... args);
template <class T, class U, class... Args>                                                    \fB(2)\fP \fI(since C++17)\fP
T& emplace(std::initializer_list<U> il, Args&&... args);
template <size_t I, class... Args>                                                            \fB(3)\fP \fI(since C++17)\fP
std::variant_alternative_t<I, variant>& emplace(Args&&... args);
template <size_t I, class U, class... Args>                                                   \fB(4)\fP \fI(since C++17)\fP
std::variant_alternative_t<I, variant>& emplace(std::initializer_list<U> il, Args&&... args);

Creates a new value in-place, in an existing variant object
1) Equivalent to emplace<I>(std::forward<Args>(args)...), where I is the zero-based index of T in Types.... This overload only participates in overload resolution if std::is_constructible_v<T, Args...> is true, and T occurs exactly once in Types...
2) Equivalent to emplace<I>(il, std::forward<Args>(args)...), where I is the zero-based index of T in Types.... This overload only participates in overload resolution if std::is_constructible_v<T, std::initializer_list<U>&, Args...> is true, and T occurs exactly once in Types...
3) First, destroys the currently contained value (if any). Then direct-initializes the contained value as if constructing a value of type T_I with the arguments std::forward<Args>(args).... If an exception is thrown, *this may become valueless_by_exception. This overload only participates in overload resolution if std::is_constructible_v<T_I, Args...> is true. The behavior is undefined if I is not less than sizeof...(Types).
4) First, destroys the currently contained value (if any). Then direct-initializes the contained value as if constructing a value of type T_I with the arguments il, std::forward<Args>(args).... If an exception is thrown, *this may become valueless_by_exception. This overload only participates in overload resolution if std::is_constructible_v<T_I, initializer_list<U>&, Args...> is true. The behavior is undefined if I is not less than sizeof...(Types).

.SH Parameters


args - constructor arguments to use when constructing the new value
il   - initializer_list argument to use when constructing the new value


.SH Return value

A reference to the new contained value.

.SH Exceptions

1-4) Any exception thrown during the initialization of the contained value.

.SH Example


// Run this code

  #include <iostream>
  #include <string>
  #include <variant>

  int main()
  {
    std::variant<std::string> v1;
    v1.emplace<0>("abc"); // OK
    std::cout << std::get<0>(v1) << '\\n';
    v1.emplace<std::string>("def"); // OK
    std::cout << std::get<0>(v1) << '\\n';

    std::variant<std::string, std::string> v2;
    v2.emplace<1>("ghi"); // OK
    std::cout << std::get<1>(v2) << '\\n';
    // v2.emplace<std::string>("abc"); -> Error
  }

.SH Output:

  abc
  def
  ghi


.SH See also


          assigns a variant
operator= \fI(public member function)\fP




